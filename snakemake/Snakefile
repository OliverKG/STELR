import os

rule all:
    input: 
        'intermediate_files/input/reads-reads.fasta',
        'intermediate_files/input/reference-reads.fasta',
        'intermediate_files/input/library-reads.fasta'

# input rules
checkpoint input:
    output:
        'intermediate_files/input/{type}-{sample_name}.f{ext}'
    params:
        file_type = '{type}',
        sample = config["sample_name"],
        in_file = lambda wildcards: os.path.abspath(config[wildcards.type])
    shell: 
        'python3 TELR_input.py input {params.file_type} {params.sample} {params.in_file}'

# alignment
def fasta_input(wildcards):
    checkpoints.input.get(type="reads")
    if not os.path.exists('intermediate_files/input/reads-{sample_name}.bam'):
        return 'intermediate_files/input/reads-{sample_name}.f{extr}'
    else: return []
rule alignment:
    input:
        fasta_input
    output:
        "intermediate_files/{config[sample_name]}.sam"
    params:
        reads = "intermediate_files/inputs/reads-{sample_name}.f{extr}",
        reference = "intermediate_files/inputs/reference-{sample_name}.f{extref}",
        out = "intermediate_files",
        sample_name = config["sample_name"],
        thread = config["thread"],
        method = config["aligner"],
        presets = config["presets"]
    shell:
        "python3 TELR_alignment.py alignment {params.reads} {params.reference} {params.out} {params.sample_name} {params.thread} {params.method} {params.presets}"

rule sort_index_bam:
    input:
        "intermediate_files/{sample_name}.sam" 
    output:
        "intermediate_files/{sample_name}_sort.bam"
    params:
        unsorted_bam = "intermediate_files/{config[sample_name]}.sam",
        sorted_bam = "intermediate_files/{config[sample_name]}_sort.bam",
        thread = config["thread"]
    conda:
        config["conda"]
        #samtools
    shell:
        "python3 TELR_alignment.py sort_index_bam {params.unsorted_bam} {params.sorted_bam} {params.thread}"

#standard variant detection
rule detect_sv:
    input:
        bam = "intermediate_files/{sample_name}_sort.bam",
        reference = "intermediate_files/input/reference-{sample_name}.f{extref}"
    output:
        "intermediate_files/{sample_name}_{sv_detector}.vcf"
    params:
        out = "intermediate_files",
        sample_name = config["sample_name"],
        thread = config["thread"]
    shell:
        "python3 TELR_sv.py detect_sv {input.bam} {input.reference} {params.out} {params.sample_name} {params.thread}"

rule parse_vcf:
    input:
        "intermediate_files/{sample_name}_{sv_detector}.vcf"
    output:
        "intermediate_files/{sample_name}.vcf_parsed.tsv.tmp"
    params:
        '"%CHROM\\t%POS\\t%END\\t%SVLEN\\t%RE\\t%AF\\t%ID\\t%ALT\\t%RNAMES\\t%FILTER\\t[ %GT]\\t[ %DR]\\t[ %DV]\n"'
    conda:
        config["conda"]
        #bcftools
    shell:
        'bcftools query -i \'SVTYPE="INS" & ALT!="<INS>"\' -f {params} {input} > {output}'

rule swap_vcf_coordinate:
    input:
        "intermediate_files/{sample_name}.vcf_parsed.tsv.tmp"
    output:
        "intermediate_files/{sample_name}.vcf_parsed.tsv.swap"
    shell:
        "python3 TELR_sv.py swap_coordinate {input} {output}"

rule rm_vcf_redundancy:
    input:
        "intermediate_files/{sample_name}.vcf_parsed.tsv.swap"
    output:
        "intermediate_files/{sample_name}.vcf_parsed.tsv"
    conda:
        config["conda"]
        #pandas
    shell:
        "python3 TELR_sv.py rm_vcf_redundancy {input} {output}"

rule write_ins_seqs:
    input:
        "intermediate_files/{sample_name}.vcf_parsed.tsv"
    output:
        "intermediate_files/{sample_name_plus}.vcf_ins.fasta"
    params:
        output_file = lambda config: f"intermediate_files/{config["sample_name"].replace("+","plus")}.vcf_ins.fasta"
    shell:
        "python3 TELR_sv.py write_ins_seqs {input} {params.output_file}"

rule filter_vcf:
    input:
        parsed_vcf = "intermediate_files/{sample_name}.vcf_parsed.tsv"
        ins_seqs = "intermediate_files/{sample_name_plus}.vcf_ins.fasta"
        library = "intermediate_files/input/library-{sample_name}.f{extl}"
    output:
        "intermediate_files/{sample_name}.vcf.filtered.tmp.tsv"
    params:
        out = "intermediate_files"
        repeatmasker_dir = "vcf_ins_repeatmask"
        sample_name = config["sample_name"]
        thread = config["thread"]
    shell:
        "python3 TELR_sv.py filter_vcf {input.parsed_vcf} {output} {input.ins_seqs} {input.library} {params.out} {params.repeatmasker_dir} {params.sample_name} {params.thread}"